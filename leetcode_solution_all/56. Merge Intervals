V2023.4.7
Solution1 : O(nlogn) and O(n)
先sort,判断是否重叠 对于非重叠部分直接加, 对于重叠部分,更新每一个interval的右区间的值为当前interval的右区间的值

class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));
        LinkedList<int[]> res = new LinkedList<>();
        for (int i = 0; i < intervals.length; i++) {
            //对于不重叠的, 直接加
            if (res.isEmpty() || res.getLast()[1] < intervals[i][0]) {
                res.add(intervals[i]);   
            } else {
                //对于重叠的,把res里最后一个更新为i的右区间
                res.getLast()[1] = Math.max(res.getLast()[1], intervals[i][1]);
            }

        }
        
        //我错在没有直接return res.toArray(new int[res.size()][]);, 而是转换后,return res,不行的
        return res.toArray(new int[res.size()][]);
    }
}

