//subarray 和 subsequence不一样, subarray是连续的, subsequence不需要连续
//耐心排序 O(nlogn) and O(n)
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] top = new int[nums.length];
        //牌堆数初始化为0
        int piles = 0;
        for (int i = 0; i < nums.length; i++) {
            //要处理的扑克牌
            int poker = nums[i];
            //左侧边界二分查找
            int left = 0, right = piles;
            while (left < right) {
                int mid = (left + right) / 2;
                if (top[mid] > poker) {
                    right = mid;
                } else if (top[mid] < poker) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            //没找到合适的牌堆,新建一个堆
            if (left == piles) piles++;
            //吧这张牌放到堆顶
            top[left] = poker;
        }
        //牌堆数就是LIS长度
        return piles;
    }
}
