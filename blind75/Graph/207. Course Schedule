class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<List<Integer>> graph =  new ArrayList<>();
        for (int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<>());
        }
        //我错在用使用i<numCourses会出界, 没有用iterator,或者 i < prerequisites.length 
        for (int i = 0; i < prerequisites.length; i++){    //2 [[1,0]] 这个case inx只能为0, 为1的时候就出界了 所以不可以这样写只能用iterator
            int[] prerequisite = prerequisites[i]; 
            int x = prerequisite[0];
            int y = prerequisite[1];
            graph.get(y).add(x);
        }
        // for (int[] prerequisite : prerequisites) {
        //     int x = prerequisite[0];
        //     int y = prerequisite[1];
        //     graph.get(y).add(x);
        // }
        return helper(graph);
    }

    public boolean helper(List<List<Integer>> graph) {
        int numCourses = graph.size();
        int[] incomingEdges = new int[numCourses];
        int[] topo = new int[numCourses];
        for (int x = 0; x < numCourses; x++) {
            for (int y : graph.get(x)) {
                incomingEdges[y]++;
            }
        }
        Queue<Integer> q = new LinkedList<>();
        int numExpanded = 0;
        //让所有入度为0的节点进q
        for (int x = 0; x < numCourses; x++) {
            if (incomingEdges[x] == 0) {
                q.offer(x); //我错在q offer进来incomingEdges[x]; 应该offer x
            }
        }
        //bfs模板
        while (!q.isEmpty()) {
            int cur = q.poll();
            numExpanded++;
            for (int nei : graph.get(cur)) { //我错在没有通过get(cur)获得cur的nei
                if (--incomingEdges[nei] == 0) {
                    q.offer(nei);//我错在offer incomingEdges[nei] 而不是直接offer nei
                }
            }

            // System.out.println(numExpanded);
        }
        return numCourses == numExpanded;
    }
}
